<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Munki | graham gilbert]]></title>
  <link href="http://grahamgilbert.com/blog/categories/munki/atom.xml" rel="self"/>
  <link href="http://grahamgilbert.com/"/>
  <updated>2015-02-12T07:42:20+00:00</updated>
  <id>http://grahamgilbert.com/</id>
  <author>
    <name><![CDATA[Graham Gilbert]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Managing Munki catalogs with Trello]]></title>
    <link href="http://grahamgilbert.com/blog/2015/02/11/managing-munki-catalogs-with-trello/"/>
    <updated>2015-02-11T12:11:30+00:00</updated>
    <id>http://grahamgilbert.com/blog/2015/02/11/managing-munki-catalogs-with-trello</id>
    <content type="html"><![CDATA[<p>Over the past few months, I&rsquo;ve been trying to take small pieces of our workflow and see if we can expand on the number of people able to manage it. We&rsquo;ve got <a href="https://github.com/autopkg/autopkg">AutoPkg</a> populating our <a href="https://github.com/munki/munki">Munki</a> repositories without any manual intervention, but we still need to edit pkgsinfo files to move items through development to testing to production catalogs. Sure, there are existing tools  like <a href="https://github.com/munki/munkiwebadmin">MunkiWebAdmin</a> or <a href="https://github.com/hjuutilainen/munkiadmin">MunkiAdmin</a>, but they either still require knowledge of how Munki works or full access to the repository via a file share of some sort. And we obviously already have a tool for assigning software to machines in Sal+ &ndash; we needed something that can speed this incredibly common task.</p>

<p>Then I cast my mind back to a conversation I had with <a href="https://twitter.com/bruienne">Pepijn Bruienne</a> at PSU last year about his workflow using <a href="https://trello.com">Trello</a> to promote items in his Munki repository. So, after pestering him for some information, I devised a workflow that matched how we worked.</p>

<h2>&ldquo;So how does it work&rdquo;, I hear you cry</h2>

<p>We have five lists on our &ldquo;Munki Package Management&rdquo; Trello board. Essentially when the script runs, it inspects the items in our Munki catalog and if they&rsquo;re not already in the Trello board, it adds them to the correct list (we ignore anything that&rsquo;s already in production. All promotions to production are done using this tool now).</p>

<p><img class="center" src="/images/posts/2015-02-11/to_testing.gif" width="427" height="240"></p>

<p>We also have lists called &ldquo;To Development&rdquo;, &ldquo;To Testing&rdquo; and &ldquo;To Production&rdquo;. Moving items into these lists will be caught by the script next time it runs, and moved to the appropriate catalog.</p>

<p><img class="center" src="/images/posts/2015-02-11/testing.gif" width="427" height="240"></p>

<p>When items finally make it to Production, we add them to a dated Production list. This allows us to have a full history of when things are added to Production and who has moved it through each stage. We&rsquo;re also big users of Slack, so we hooked up it&rsquo;s Tello integration to post a message to our notficiations channel to let our team know when items are added into Munki.</p>

<p>You can grab the script from <a href="https://github.com/pebbleit/munki-trello">pebble.it&rsquo;s GitHub account</a>, or if you&rsquo;re Docker inclined there&rsquo;s a <a href="https://registry.hub.docker.com/u/pebbleit/munki-trello/">container that has everything you need</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Slides and notes from Twisting Munki]]></title>
    <link href="http://grahamgilbert.com/blog/2014/11/07/slides-and-notes-from-twisting-munki/"/>
    <updated>2014-11-07T00:51:33+00:00</updated>
    <id>http://grahamgilbert.com/blog/2014/11/07/slides-and-notes-from-twisting-munki</id>
    <content type="html"><![CDATA[<p>Firstly, thanks if you came to my talk and putting up with me! You can get my slides and code from the <a href="https://github.com/grahamgilbert/mactech_2014">GitHub repository</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Personal Automation: Munki (Part 2)]]></title>
    <link href="http://grahamgilbert.com/blog/2014/07/27/personal-automation-munki-part-2/"/>
    <updated>2014-07-27T11:21:37+01:00</updated>
    <id>http://grahamgilbert.com/blog/2014/07/27/personal-automation-munki-part-2</id>
    <content type="html"><![CDATA[<p>The first step to getting any Mac set up is to get some software onto it. I&rsquo;m not going to cover how to set up <a href="https://code.google.com/p/munki/wiki/GettingStartedWithMunki">Munki</a> or <a href="https://github.com/autopkg/autopkg/wiki/Getting-Started">AutoPkg</a> &ndash; there are lots of other places for that information.</p>

<p>As a sysadmin, I&rsquo;m forever testing things. Rather than destroy my own machine, I like to do this in Virtual Machines. My preferred virtualisation solution is VMware Fusion, but unfortunately it&rsquo;s not very easy to deploy out of the box. You need to do a little bit of work to get it into a package that you can import into Munki, but fortunately the process is <a href="http://kb.vmware.com/selfservice/microsites/search.do?language=en_US&amp;cmd=displayKC&amp;externalId=2058680">well documented on VMware&rsquo;s site</a>.</p>

<p>The next piece of &lsquo;non standard&rsquo; software I need is <a href="http://brew.sh">Homebrew</a>. The installation method listed on their site is to run a terminal command as the current user. The first part of this is obviously fine &ndash; Munki has several methods to run scripts (payload free packages, nopkg), but it runs everything as root. Fortunately, as I&rsquo;m deploying my own machine, I can make some assumptions about where Homebrew will be installed. The first assumption I can make is that there will only be one user on the machine, and the second is that I&rsquo;m going to be logged in most of the time (as my laptop is encrypted, it&rsquo;s either off or logged in).</p>

<p>I&rsquo;m going to utilise a <code>nopkg</code> pkginfo file to perform the installation. The first part of our script to install Homebrew is to make sure that a user (me!) is logged in. Homebrew doesn&rsquo;t like being owned by root, so first we need to make sure that there is a user logged in.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;!/bin/bash&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CURRENT_USER<span class="o">=</span>&lt;code&gt;/bin/ls -l /dev/console | /usr/bin/awk <span class="s1">&#39;{ print $3 }&#39;</span>&lt;/code&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;if <span class="o">[</span> &amp;ldquo;<span class="nv">$CURRENT_USER</span>&amp;rdquo; <span class="o">==</span> &amp;lsquo;root&amp;rsquo; <span class="o">]</span>; <span class="k">then</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;# this can<span class="err">&#39;</span>t run at the login window, we need the current user
</span><span class='line'><span class="nb">exit </span>1
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;fi
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>So now we know that there&rsquo;s a user logged in, and who that user is. Time to install Homebrew as the current user.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>mkdir -p /usr/local
</span><span class='line'>mkdir -p /usr/local/homebrew
</span><span class='line'>mkdir -p /usr/local/bin
</span><span class='line'>chown <span class="nv">$CURRENT_USER</span>:&lt;em&gt;developer /usr/local/homebrew
</span><span class='line'>chown <span class="nv">$CURRENT_USER</span>:&lt;/em&gt;developer /usr/local/bin&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;download and install homebrew&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;su <span class="nv">$CURRENT_USER</span> -c &amp;ldquo;/bin/bash -o pipefail -c &amp;lsquo;/usr/bin/curl -skSfL &lt;a <span class="nv">href</span><span class="o">=</span><span class="s2">&quot;https://github.com/mxcl/homebrew/tarball/master&quot;</span>&gt;https://github.com/mxcl/homebrew/tarball/master&lt;/a&gt; | <span class="o">(</span><span class="nb">cd</span> /usr/local ; /usr/bin/tar xz -m &amp;mdash;strip 1 -C homebrew; ln -s /usr/local/homebrew/bin/brew /usr/local/bin/brew<span class="o">)</span>&amp;rsquo;&amp;rdquo;
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>As we&rsquo;re using a <code>nopkg</code> with Munki rather than a payload free package, we&rsquo;ve not left any receipts, so Munki doesn&rsquo;t know if Homebrew is installed. We&rsquo;re going to use an installs array to tell Munki what to look for when determining whether Homebrew is installed or not.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;key&gt;</span>installs<span class="nt">&lt;/key&gt;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;pre&gt;&lt;code&gt;</span><span class="ni">&amp;lt;</span>array<span class="ni">&amp;gt;</span>
</span><span class='line'>    <span class="ni">&amp;lt;</span>dict<span class="ni">&amp;gt;</span>
</span><span class='line'>        <span class="ni">&amp;lt;</span>key<span class="ni">&amp;gt;</span>path<span class="ni">&amp;lt;</span>/key<span class="ni">&amp;gt;</span>
</span><span class='line'>        <span class="ni">&amp;lt;</span>string<span class="ni">&amp;gt;</span>/usr/local/bin/brew<span class="ni">&amp;lt;</span>/string<span class="ni">&amp;gt;</span>
</span><span class='line'>        <span class="ni">&amp;lt;</span>key<span class="ni">&amp;gt;</span>type<span class="ni">&amp;lt;</span>/key<span class="ni">&amp;gt;</span>
</span><span class='line'>        <span class="ni">&amp;lt;</span>string<span class="ni">&amp;gt;</span>file<span class="ni">&amp;lt;</span>/string<span class="ni">&amp;gt;</span>
</span><span class='line'>    <span class="ni">&amp;lt;</span>/dict<span class="ni">&amp;gt;</span>
</span><span class='line'><span class="ni">&amp;lt;</span>/array<span class="ni">&amp;gt;</span>
</span><span class='line'><span class="nt">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>You might be crying &ldquo;but Homebrew needs the Xcode Command Line Tools installed!&rdquo; &ndash; and you&rsquo;d be 100% correct. You have the option of importing the downloaded package into Munki, but I have adapted <a href="https://github.com/timsutton/osx-vm-templates/blob/master/scripts/xcode-cli-tools.sh">Tim Sutton&rsquo;s script</a> into a <code>nopkg</code>. To find out what&rsquo;s installed, I ran <a href="http://www.fernlightning.com/doku.php?id=software%3afseventer%3astart">fseventer</a> and chose a random file to act as my installs array. I&rsquo;ve posted the pkginfos for both the <a href="https://github.com/grahamgilbert/macscripts/blob/master/Munki/pkginfos/Xcode/XcodeCLITools-2014.07.15.plist">Xcode CLI tools</a> and all of the <a href="https://github.com/grahamgilbert/macscripts/tree/master/Munki/pkginfos/Homebrew">Homebrew installs</a> on Github.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Personal Automation (Part 1)]]></title>
    <link href="http://grahamgilbert.com/blog/2014/07/26/personal-automation-part-1/"/>
    <updated>2014-07-26T11:27:00+01:00</updated>
    <id>http://grahamgilbert.com/blog/2014/07/26/personal-automation-part-1</id>
    <content type="html"><![CDATA[<p><a href="http://grahamgilbert.com/blog/2014/04/04/updating-boxen/">Earlier this year</a>, I professed my love of Boxen &ndash; the personal automation solution based on Puppet released by Github. Indeed, it served me well for quite some time, but I began to find myself spending more time fixing Boxen than actually getting things done. As Boxen was designed for internal use at Github, it set some things up how they liked them &ndash; which wasn&rsquo;t necesarily how I liked them. Sysadmins have similar needs to developers, but not exactly the same.</p>

<p>Then I updated Boxen. All of my modules were out of date, so I spent a good couple of hours updating all of them so they worked again. Ugh.</p>

<p>So I started looking at moving to my own solution. One of my major irritations when using Boxen was that it didn&rsquo;t really handle updating your apps &ndash; you got whatever version the module author decided to install and then you had to hope that there was an updatng mechanism built in. I&rsquo;ve said before that there is no better method of getting software onto your Mac then Munki, so the first decison was straightforward. The rest took a little thought.</p>

<h2>The six P&rsquo;s</h2>

<p>My first requirement was that I shouldn&rsquo;t need to run anything to get my configuration to apply. Boxen requires that you run the <code>boxen</code> command periodically across each of your Macs to get the configuration applied. This wasn&rsquo;t always practical. I needed something that would run in the background and keep itself up to date.</p>

<p>As I said before, I really disliked how Boxen installs software. Munki does a much better job, and AutoPkg makes it trivial to make sure you have the latest software version. Being a sysadmin, I need more than simple drag and drop apps and packages though &ndash; I make extensive use of <a href="http://brew.sh">Homebrew</a> to install command line tools like <a href="http://packer.io">Packer</a>, so I needed to come up with a way of installing these with Munki.</p>

<p>However, Munki isn&rsquo;t the best tool for managing my configuration. I&rsquo;ve been using Puppet to manage the Macs  I look after for nearly three years now, and I wanted to base my system on it as I&rsquo;ve already done a lot of the work with making OS X specific modules. I also wanted to use the modules made for Boxen as much as possible (some made too many assumptions about where they were running, so couldn&rsquo;t be re-used.</p>

<p>So to recap:</p>

<ul>
<li>Munki for software deployment.</li>
<li>Puppet must run in the background periodically</li>
<li>The configuration must update itself &ndash; I don&rsquo;t want to have to sync code across machines.</li>
<li>Where possible, re-use existing Puppet modules</li>
</ul>


<p>Over the next few posts, I&rsquo;ll go over the different parts of this solution, how I put it together and how you might be able to use this.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Binding to Active Directory with Munki]]></title>
    <link href="http://grahamgilbert.com/blog/2014/04/01/binding-to-active-directory-with-munki/"/>
    <updated>2014-04-01T20:15:39+01:00</updated>
    <id>http://grahamgilbert.com/blog/2014/04/01/binding-to-active-directory-with-munki</id>
    <content type="html"><![CDATA[<p>Many organisations need to bind their Macs to AD. There are quite a few options however, that need to be changed. It&rsquo;s quite  a straightforward process to automate this with Munki, although you do have a few options to consider.</p>

<p>First off, how are you going to deliver the actual bind script? You have the option of a <a href="https://code.google.com/p/munki/wiki/ManagingPrintersWithMunki#Alternate_Method_Using_nopkg">no-pkg pkginfo</a> file, with the script directly in the pkginfo plist. Whilst the script is now easily editable in the pkginfo, it does pose a security issue in that the catalog is kept in /Library/Managed Installs/catalogs, which will contain your script. Along with your AD bind account&rsquo;s details. Whoops!</p>

<h2>Prepare the Bind!</h2>

<p>My preferred way of deploying the bind script is with a payload-free package made with The Luggage. My bind script is nothing special, it was originally borrowed from DeployStudio. You can find the <a href="https://github.com/grahamgilbert/macscripts/blob/master/AD%20Bind/postinstall">script</a> and the <a href="https://github.com/grahamgilbert/macscripts/blob/master/AD%20Bind/Makefile">Makefile</a> on my <a href="https://github.com/grahamgilbert/macscripts/tree/master/AD%20Bind">macscripts repo</a>. If you need a primer on The Luggage, <a href="http://grahamgilbert.com/blog/2013/08/09/the-luggage-an-introduction/">I wrote about it in August 2013</a>. You just need to edit the variables at the top of the script to suit your environment and build the package.</p>

<p>So you&rsquo;ve got the machine bound to AD. Great. What happens if the binding doesn&rsquo;t go to plan? Or a well meaning tech manages to unbind the machine, but can&rsquo;t manage to re-bind it? Or even worse, the user manages to unbind it themselves? We need to make Munki check that the Mac is still bound to AD.</p>

<!--more-->


<h2>installcheck_script.sh</h2>

<p>``` bash</p>

<h1>!/bin/sh</h1>

<h1>You need to change this.</h1>

<h1>The Domain we&rsquo;re supposed to be on</h1>

<p>DOMAIN=&ldquo;ad.company.com&rdquo;</p>

<h2>STOP EDITING</h2>

<h1>The version from dsconfigad</h1>

<p>ACTUAL_DOMAIN=<code>/usr/sbin/dsconfigad -show | /usr/bin/grep -i "Active Directory Domain" | /usr/bin/sed -n 's/[^.]*= //p'</code></p>

<p>if [ &ldquo;$ACTUAL_DOMAIN&rdquo; = &ldquo;$DOMAIN&rdquo; ]</p>

<pre><code>then
# We're on the right domain, no need to install
exit 1
</code></pre>

<p>else</p>

<pre><code># Domain isn't being returned from dsconfigad, need to install
exit 0
</code></pre>

<p>fi
```</p>

<p>You should save this as install <code>check_script.sh</code> in the same directory as your binding package. This script is querying the Active Directory domain the Mac is on and checking it&rsquo;s the one you want.</p>

<p>Simple.</p>

<p>Job done.</p>

<p>Right&hellip;?</p>

<h2>Not quite finished</h2>

<p>The main issue with using an <code>installcheck_script</code> is that we&rsquo;re bypassing every other mechanism that Munki uses to check if an item needs to be installed, which means that if we ever need to update our AD bind package and install it, or if the Mac was previously bound to AD, Munki will cheerfully ignore the package because as far as it&rsquo;s concerned, if it passes the installcheck_script, everything&rsquo;s fine and dandy.</p>

<h2>installcheck_script.sh take 2</h2>

<p>``` bash</p>

<h1>!/bin/sh</h1>

<h1>You need to change these.</h1>

<h1>The Domain we&rsquo;re supposed to be on</h1>

<p>DOMAIN=&ldquo;ad.company.com&rdquo;</p>

<h1>The version of the package (today&rsquo;s date if created using the usual Luggage Makefile)</h1>

<p>PKG_VERSION=&ldquo;20140401&rdquo;</p>

<h1>The identifier of the package</h1>

<p>PKG_ID=&ldquo;com.grahamgilbert.ad-bind&rdquo;</p>

<h2>STOP EDITING</h2>

<h1>The version from dsconfigad</h1>

<p>ACTUAL_DOMAIN=<code>/usr/sbin/dsconfigad -show | /usr/bin/grep -i "Active Directory Domain" | /usr/bin/sed -n 's/[^.]*= //p'</code></p>

<h1>The version installed from pkgutil</h1>

<p>VERSION_INSTALLED=<code>/usr/sbin/pkgutil --pkg-info ${PKG_ID} | /usr/bin/grep version | /usr/bin/sed 's/^[^:]*: //'</code>
if [ &ldquo;$ACTUAL_DOMAIN&rdquo; = &ldquo;$DOMAIN&rdquo; ]</p>

<pre><code>then
# We're on the right domain, make sure we've got the right version of the package
if [ "$VERSION_INSTALLED" = "$PKG_VERSION" ]
then
    # Everything's ok, no need to install
    exit 1
else
    # Package is out of date, need to install
    exit 0
fi
</code></pre>

<p>else</p>

<pre><code># Domain isn't being returned from dsconfigad, need to install
exit 0
</code></pre>

<p>fi
```</p>

<p>This is a little more complicated, but not much. First off we&rsquo;re doing the same check as before, making sure we&rsquo;re actually bound to the domain. If we aren&rsquo;t, we obviously need to install the package, so that&rsquo;s the end of that. If we are bound, we next need to check which version of the package we have. As previously mentioned, Munki would usually do this for us, but by using the installcheck_script, we&rsquo;ve engaged the &ldquo;leave me alone, I know what the fuck I&rsquo;m doing&rdquo; mode in Munki, so we&rsquo;re implementing that check ourselves. If the version or package identifier don&rsquo;t match, we want our bind script installed, screw those other guys with their not-as-good-as-our-way of binding.</p>

<p>All that&rsquo;s left now is to <code>munkiimport</code> your package with your script as an <code>installcheck_script</code>:</p>

<p><code>bash
$ /usr/local/munki/munkiimport ad-bind.pkg --installcheck_script=installcheck_script.sh
</code></p>

<p>There you have it, how to keep a Mac bound to AD with Munki. You may wish to change some other settings later on (particularly if you have to do battle with a .local domain), but this will get you going with a basic AD bind.</p>
]]></content>
  </entry>
  
</feed>
