<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[graham gilbert]]></title>
  <link href="http://grahamgilbert.com/atom.xml" rel="self"/>
  <link href="http://grahamgilbert.com/"/>
  <updated>2015-07-10T09:31:24+01:00</updated>
  <id>http://grahamgilbert.com/</id>
  <author>
    <name><![CDATA[Graham Gilbert]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using the Sal API]]></title>
    <link href="http://grahamgilbert.com/blog/2015/07/10/using-the-sal-api/"/>
    <updated>2015-07-10T11:12:36+01:00</updated>
    <id>http://grahamgilbert.com/blog/2015/07/10/using-the-sal-api</id>
    <content type="html"><![CDATA[<p>As previously mentioned, Sal now has an <a href="https://github.com/salopensource/sal/blob/master/docs/API.md">API</a>. You might be wondering what you can do with this wonderous API. This is a simple example of using it to automate building packages to enrol Macs into Sal.</p>

<p>The basic workflow of this script is:</p>

<ul>
<li>Use the API to get a list of all Machine Groups in Sal &ndash; this will return JSON (a markup language that is easily parsable with languages like Python)</li>
<li>Download the Sal postflight scripts</li>
<li>Download the latest Facter installer</li>
<li>For each machine group, build a package that will install all of the packages and then set the correct Sal preferences.</li>
</ul>


<p><a href="https://gist.github.com/grahamgilbert/8ccba318d3ecadee02b1">You can find the script in this Gist</a>. I&rsquo;m not going to go through the script line by line, but we&rsquo;ll cover how to configure it.</p>

<p>First off you will need an API key configuring. Log into Sal as a user with Global Admin privelages and choose the &lsquo;person&rsquo; menu at the top right and then choose Settings. From the sidebar, choose API keys and then choose to make a new one. Give it a name so you can recognise it &ndash; I called this one &ldquo;PKG Generator&rdquo;. You will then be given a public key and a private key. Make a note of them, we&rsquo;ll need them in the next section.</p>

<h2>Configuring the script</h2>

<p>Edit the variables at the top to match your environment:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># No trailing slash on this one - I was lazy and didn&#39;t check for it</span>
</span><span class='line'><span class="n">SAL_URL</span> <span class="o">=</span> <span class="s">&quot;https://sal.yourcompany.com&quot;</span>
</span><span class='line'><span class="n">PUBLIC_KEY</span> <span class="o">=</span> <span class="s">&quot;yourpublickeyhere&quot;</span>
</span><span class='line'><span class="n">PRIVATE_KEY</span> <span class="o">=</span> <span class="s">&quot;yourreallyreallyreallylongprivatekeyhere&quot;</span>
</span><span class='line'><span class="n">PKG_IDENTIFIER</span> <span class="o">=</span> <span class="s">&quot;com.yourcompany.sal_enrol&quot;</span>
</span><span class='line'><span class="n">SAL_PKG</span> <span class="o">=</span> <span class="s">&quot;https://github.com/salopensource/sal/releases/download/v0.4.0/sal_scripts.pkg&quot;</span>
</span><span class='line'><span class="n">FACTER_PKG</span> <span class="o">=</span> <span class="s">&quot;https://downloads.puppetlabs.com/mac/facter-latest.dmg&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>There are some caveats with this script:</p>

<ul>
<li>It will spit the packages out in your current directory. Make sure you&rsquo;ve <code>cd</code>-ed into where you want the packages to be generated.</li>
<li>It uses <code>urllib2</code> to request the information from Sal and to download the packages &ndash; this means that there is no verification of the SSL certificates, so make sure you know where you&rsquo;re connecting to.</li>
</ul>


<p>All ready to run it?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>sudo python sal_package_generator.py
</span></code></pre></td></tr></table></div></figure>


<p>And you&rsquo;ll get a directory full of packages that will get your fleet reporting into Sal.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Munki DND]]></title>
    <link href="http://grahamgilbert.com/blog/2015/07/07/munki-dnd/"/>
    <updated>2015-07-07T17:46:44+01:00</updated>
    <id>http://grahamgilbert.com/blog/2015/07/07/munki-dnd</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been wanting to get stuck in with a simple Swift project for a while, but couldn&rsquo;t think of anything suitable for a first project (<a href="https://github.com/grahamgilbert/imagr">Imagr</a> was originally going to be that project, but I don&rsquo;t think it would ever have been made if I chose Swift), until I saw <a href="https://grpugh.wordpress.com/2015/07/03/a-do-not-disturb-application-for-munki/">Dr Graham R Pugh&rsquo;s Do Not Disturb application</a>. I thought it was an excellent idea that could be made even better by being a manu bar app.</p>

<p><img class="center" src="http://grahamgilbert.com/images/posts/2015-07-07/active.png"></p>

<p>Enter <a href="https://github.com/grahamgilbert/munki-dnd">Munki DND</a> &ndash; it extends Graham&rsquo;s idea by allowing the administrator to configure the number of hours the user is allowed to suppress notifications for, as well as living in the menu bar so the user can check how long they&rsquo;ve got until notifications become active again.</p>

<p><img class="center" src="http://grahamgilbert.com/images/posts/2015-07-07/disabled.png"></p>

<p>You can grab version 0.0.1 of Munki DND from the <a href="https://github.com/grahamgilbert/munki-dnd/releases/tag/v0.0.1">Releases page on GitHub</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The future of Sal]]></title>
    <link href="http://grahamgilbert.com/blog/2015/06/26/the-future-of-sal/"/>
    <updated>2015-06-26T09:40:31+01:00</updated>
    <id>http://grahamgilbert.com/blog/2015/06/26/the-future-of-sal</id>
    <content type="html"><![CDATA[<p>As some of you may know, yesterday was my last day at pebble.it. Since I announced I was leaving, I’ve been getting asked this pretty regularly, so I thought I’d answer it here.</p>

<p>My new job uses Munki extensively, and I expect to be using Sal there. As such, development of Sal will continue. I no longer have commit access to the Sal Software organisation, so I’ve forked the project and have set up <a href="https://github.com/salopensource">Sal Open Source</a> as an organisation on GitHub &ndash; hopefully this will be the last time anything needs to change. I’ll be moving the preference domain in version 0.4.0 of the client side scripts to <code>com.github.salopensource.sal</code> &ndash; once again, this should be the last time things need to change.</p>

<p>So, what else can you expect from Sal in the near future? The next release will have a GUI for managing your plugins, and I’ve started work on a basic API, which should make it easier for people to extend Sal in any language you like. For example, I’ve been working on a way to sign Puppet certificates based on whether it’s a known machine in Sal, with the machine being created via the API if it doesn’t already exist at imaging time (using Imagr, naturally).</p>

<p>It’s exciting times for users of all the projects I’m working on &ndash; in addition to these changes, I have some changes planned for <a href="https://github.com/grahamgilbert/Crypt">Crypt</a>, and of course <a href="https://github.com/grahamgilbert/imagr">Imagr</a> is still on the development rollercoaster.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Running Puppet Server in Docker Part 2: r10k]]></title>
    <link href="http://grahamgilbert.com/blog/2015/06/24/running-puppet-server-in-docker-part-2-r10k/"/>
    <updated>2015-06-24T14:49:31+01:00</updated>
    <id>http://grahamgilbert.com/blog/2015/06/24/running-puppet-server-in-docker-part-2-r10k</id>
    <content type="html"><![CDATA[<p>Last time we got our Puppet Server up and running &ndash; now we need to put some Puppet modules on it so we can use it.</p>

<p>To do that, we&rsquo;re going to use r10k. It&rsquo;s a tool that uses a control git repository that contains something called a puppetfile- a file that lists all of the puppet modules you want to use, either from the puppet forge or from git repositories. You may want to keep this module private by using a paid account on GitHub if your configuration contains secrets, but  it doesn&rsquo;t have to be &ndash; mine doesn&rsquo;t have anything particularly sensitive in, so here it is: <a href="https://github.com/grahamgilbert/personal-puppet">grahamgilbert/personal-puppet</a>. <!--more--></p>

<h2>The Control module</h2>

<p>Puppet recommends the use of environments &ndash; a way of separating your clients into groups &ndash; usually this is test and production groups. r10k uses git branches to determine which environments you have, so we&rsquo;re going to set up our repository. The default branch is called <code>master</code>, but we want ours to be called <code>production</code> &ndash; Github has some excellent <a href="https://help.github.com/articles/setting-the-default-branch/">documentation</a> on the subject. I recommend accepting GitHub&rsquo;s suggestion of putting a README in your repository so you can clone it right away.</p>

<h2>The Puppetfile</h2>

<p>Now we&rsquo;ve got our control repo set up, we can clone it so we can work on it.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git clone https://github.com/yourusername/yourcontolrepo</span></code></pre></td></tr></table></div></figure>


<p>If you&rsquo;re familiar with Puppet, this will be familiar &ndash; an environment is what you would have once put at <code>/etc/puppet</code> &ndash; the only change is that you can override options on a per-environment basis by using <code>environment.conf</code>. In my control repo, I have a default manifest at the top of the environment rather than in <code>manifests</code> for example. (<a href="https://docs.puppetlabs.com/puppet/latest/reference/config_file_environment.html">more information</a>)</p>

<p>At its simplest, a Puppetfile is just a list of modules we want to use. As we&rsquo;re just starting off, we can use pre-built ones from GitHub and the forge. We&rsquo;re going to get Munki installed on a client, so we&rsquo;ll use my MacAdmin module. One thing to note is that r10k won&rsquo;t resolve dependencies for you, so be sure to specify any modules the module you need. A simple Puppetfile is below:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">mod</span> <span class="s1">&#39;mac_admin&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="ss">:git</span> <span class="o">=&gt;</span> <span class="s1">&#39;https://github.com/grahamgilbert/puppet-mac_admin&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">mod</span> <span class="s1">&#39;mac_profiles_handler&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="ss">:git</span> <span class="o">=&gt;</span> <span class="s1">&#39;https://github.com/ryanycoleman/rcoleman-mac_profiles_handler&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">mod</span> <span class="s1">&#39;mac_facts&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="ss">:git</span> <span class="o">=&gt;</span> <span class="s1">&#39;https://github.com/grahamgilbert/grahamgilbert-mac_facts.git&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">mod</span> <span class="s1">&#39;repository&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="ss">:git</span> <span class="o">=&gt;</span> <span class="s1">&#39;https://github.com/boxen/puppet-repository&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">mod</span> <span class="s1">&#39;outset&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="ss">:git</span> <span class="o">=&gt;</span> <span class="s1">&#39;https://github.com/grahamgilbert/puppet-outset&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">mod</span> <span class="s1">&#39;stdlib&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="ss">:git</span> <span class="o">=&gt;</span> <span class="s1">&#39;https://github.com/puppetlabs/puppetlabs-stdlib&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Configuring r10k</h2>

<p>The next piece of the puzzle is to set up r10k to download our repository. I&rsquo;m running r10k directly on my Docker host, but this could easily be (and probably should be) put into a Docker container. First off, let&rsquo;s get r10k installed:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>gem install r10k
</span></code></pre></td></tr></table></div></figure>


<p>r10k get&rsquo;s in configuration from <code>/etc/r1ok.yaml</code>, so let&rsquo;s create that:</p>

<figure class='code'><figcaption><span>/etc/r10k.yaml</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="c1"># The location to use for storing cached Git repos</span>
</span><span class='line'><span class="l-Scalar-Plain">:cachedir</span><span class="p-Indicator">:</span> <span class="s">&#39;/var/cache/r10k&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># A list of git repositories to create</span>
</span><span class='line'><span class="l-Scalar-Plain">:sources</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="c1"># This will clone the git repository and instantiate an environment per</span>
</span><span class='line'>  <span class="c1"># branch in /etc/puppet/environments</span>
</span><span class='line'>  <span class="l-Scalar-Plain">:personal-puppet</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">remote</span><span class="p-Indicator">:</span> <span class="s">&#39;https://github.com/yourusername/yourcontrolrepo&#39;</span>
</span><span class='line'>    <span class="l-Scalar-Plain">basedir</span><span class="p-Indicator">:</span> <span class="s">&#39;/usr/local/docker/puppetserver/puppet/environments&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Puppet Conf</h2>

<p>The final piece of configuration for today will be to set our Puppet Server to use environments. Add the following to <code>/usr/local/docker/puppetserver/puppet/puppet.conf</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='ini'><span class='line'><span class="k">[main]</span>
</span><span class='line'><span class="na">logdir</span><span class="o">=</span><span class="s">/var/log/puppet</span>
</span><span class='line'><span class="na">vardir</span><span class="o">=</span><span class="s">/var/lib/puppet</span>
</span><span class='line'><span class="na">ssldir</span><span class="o">=</span><span class="s">/var/lib/puppet/ssl</span>
</span><span class='line'><span class="na">rundir</span><span class="o">=</span><span class="s">/var/run/puppet</span>
</span><span class='line'><span class="na">factpath</span><span class="o">=</span><span class="s">$vardir/lib/facter</span>
</span><span class='line'><span class="na">environmentpath</span><span class="o">=</span><span class="s">$confdir/environments</span>
</span><span class='line'><span class="na">pluginsync</span><span class="o">=</span><span class="s">true</span>
</span><span class='line'>
</span><span class='line'><span class="k">[master]</span>
</span><span class='line'><span class="c1"># These are needed when the puppetmaster is run by passenger</span>
</span><span class='line'><span class="c1"># and can safely be removed if webrick is used.</span>
</span><span class='line'><span class="na">ssl_client_header</span> <span class="o">=</span> <span class="s">SSL_CLIENT_S_DN</span>
</span><span class='line'><span class="na">ssl_client_verify_header</span> <span class="o">=</span> <span class="s">SSL_CLIENT_VERIFY</span>
</span><span class='line'><span class="na">autosign</span> <span class="o">=</span> <span class="s">true</span>
</span><span class='line'><span class="na">environmentpath</span> <span class="o">=</span> <span class="s">$confdir/environments</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Gimmie some modules</h2>

<p>We&rsquo;re ready to get some modules installed on the Puppet Server:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>r10k deploy environment -pv
</span></code></pre></td></tr></table></div></figure>


<p>You&rsquo;ll see all of the modules you specified in your Puppetfile download theselves to the right place. But of course, we&rsquo;re not quite ready to use this for applying configuration to our Macs yet &ndash; we have modules, but we&rsquo;ve not applied the config to specific machines. In the next post we&rsquo;ll cover how we use Hiera to do this.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Running Puppet Server in Docker]]></title>
    <link href="http://grahamgilbert.com/blog/2015/06/22/running-puppet-server-in-docker/"/>
    <updated>2015-06-22T12:29:55+01:00</updated>
    <id>http://grahamgilbert.com/blog/2015/06/22/running-puppet-server-in-docker</id>
    <content type="html"><![CDATA[<p>Back when I started using Puppet, configuring a Puppet Master could be pretty tricky as there were several moving parts (it was a Rack application, so needed to run behind something like <a href="https://www.phusionpassenger.com/">Passenger</a> if you had any number of clients). Thankfully, the new <a href="https://github.com/puppetlabs/puppet-server">Puppet Server</a> simplifies things massively &ndash; it&rsquo;s just one installation to get things working in a way that would be suitable for putting straight into production.</p>

<p>Over the next few posts, I&rsquo;ll take you through setting up the Puppet Server (running on Docker, naturally!), using r10k and git for managing your modules and using Hiera to configure your Macs &ndash; we&rsquo;ll apply some configuration to a Mac without writing a single line of Puppet code .</p>

<h1>Why?</h1>

<p>You might well be thinking &ldquo;why would I want to use Puppet?&rdquo; After all, you&rsquo;ve already got Munki. There are two main reasons I&rsquo;ve chosen to go back to using a Puppet Server in conjunction with Munki.</p>

<ol>
<li>It&rsquo;s nice to have a fallback. If I manage to do something stupid and nuke my Munki install, or my customers manage to do the same, I&rsquo;ve got some way of getting the machines back under control.</li>
<li>&ldquo;Free&rdquo; SSL certs &ndash; this might not be a priority now, but it gives you an easy to to secure your Munki repository later on (which we may cover in a later post).<!--more--></li>
</ol>


<h1>Let&rsquo;s get started</h1>

<p>First off, you&rsquo;re going to need a Linux server with Docker installed. Installing it is beyond the scope of this post, but I do recommend you head over to <a href="http://www.digitalocean.com/?refcode=ce1e0f3880e1">Digital Ocean</a> (disclaimer: referral link). They will get you up and running with a server with Docker pre-installed in under a minute for not much money.  I run mine on Ubuntu 14, but you can choose whichever flavour of Linux you prefer.</p>

<p>You will also need a DNS entry that points to your server&rsquo;s IP address. Whilst you could get away with fudging it by editing /etc/hosts, it&rsquo;s a lot of <a href="http://www.oxforddictionaries.com/definition/english/faff">faff</a>.</p>

<h1>Dockers, images and containers</h1>

<p>I&rsquo;ve already made a Docker image that has Puppet Server in it. Let&rsquo;s pull it down:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>docker pull grahamgilbert/puppetserver
</span></code></pre></td></tr></table></div></figure>


<p>And fire it up:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>docker run -d --name<span class="o">=</span>puppetserver <span class="se">\</span>
</span><span class='line'>-e <span class="nv">PUPPETSERVER_JAVA_ARGS</span><span class="o">=</span><span class="s2">&quot;-Xms384m -Xmx384m -XX:MaxPermSize=256m&quot;</span> <span class="se">\</span>
</span><span class='line'>-p 0.0.0.0:8140:8140 <span class="se">\</span>
</span><span class='line'>-h puppet.yourdomain.com <span class="se">\</span>
</span><span class='line'>grahamgilbert/puppetserver
</span></code></pre></td></tr></table></div></figure>


<p>You will need to change the amount of memory assigned to the puppet server depending on how much memory is in your actual server before going to production but for now, 384mb will be fine as we&rsquo;re just setting things up.</p>

<p>BUT there are a few things that we need to persist otherwise our server won&rsquo;t be very useful. First off, let&rsquo;s attach to the container so we can have a look around:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>docker <span class="nb">exec</span> -t -i puppetserver bash
</span></code></pre></td></tr></table></div></figure>


<p>You&rsquo;ll be looking at a bash prompt now. First off, check that <code>/etc/puppet</code> and <code>/etc/puppetserver</code> have <em>stuff</em> in them. What&rsquo;s in there isn&rsquo;t important at this stage. We also need to run the Puppet client on the server to move some supporting files in place. We first need to enable auto signing of certificates in <code>/etc/puppet/puppet.conf</code> (we&rsquo;ll cover this more later):</p>

<figure class='code'><figcaption><span>/etc/puppet/puppet.conf</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">[</span>main<span class="o">]</span>
</span><span class='line'><span class="nv">logdir</span><span class="o">=</span>/var/log/puppet
</span><span class='line'><span class="nv">vardir</span><span class="o">=</span>/var/lib/puppet
</span><span class='line'><span class="nv">ssldir</span><span class="o">=</span>/var/lib/puppet/ssl
</span><span class='line'><span class="nv">rundir</span><span class="o">=</span>/var/run/puppet
</span><span class='line'><span class="nv">factpath</span><span class="o">=</span><span class="nv">$vardir</span>/lib/facter
</span><span class='line'><span class="nv">templatedir</span><span class="o">=</span><span class="nv">$confdir</span>/templates
</span><span class='line'>
</span><span class='line'><span class="o">[</span>master<span class="o">]</span>
</span><span class='line'><span class="c"># These are needed when the puppetmaster is run by passenger</span>
</span><span class='line'><span class="c"># and can safely be removed if webrick is used.</span>
</span><span class='line'><span class="nv">ssl_client_header</span> <span class="o">=</span> SSL_CLIENT_S_DN
</span><span class='line'><span class="nv">ssl_client_verify_header</span> <span class="o">=</span> SSL_CLIENT_VERIFY
</span><span class='line'><span class="nv">autosign</span> <span class="o">=</span> <span class="nb">true</span>
</span></code></pre></td></tr></table></div></figure>


<p>And then exit the container, stop it and start it up again:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span><span class="nb">exit</span>
</span><span class='line'><span class="nv">$ </span>docker stop puppetserver
</span><span class='line'><span class="nv">$ </span>docker start puppetserver
</span></code></pre></td></tr></table></div></figure>


<p>Take a look at the container&rsquo;s logs &ndash; Puppet Server can take a few seconds to be ready, so look for the line that says it&rsquo;s ready to accept connections:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>docker logs puppetserver
</span></code></pre></td></tr></table></div></figure>


<p>When it&rsquo;s ready, enter the container again and run the puppet agent.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>docker <span class="nb">exec</span> -t -i puppetserver bash
</span><span class='line'><span class="nv">$ </span>puppet agent -t
</span></code></pre></td></tr></table></div></figure>


<p>Provided that ran with no errors, we can exit out of the container.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span><span class="nb">exit</span>
</span></code></pre></td></tr></table></div></figure>


<p>We&rsquo;re now going to copy the parts we need to persist to the file system of the host machine &ndash; I like to keep my docker related things in <code>/usr/local/docker</code> but it&rsquo;s up to you.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>mkdir -p /usr/local/docker/puppetserver
</span></code></pre></td></tr></table></div></figure>


<p>We&rsquo;re going to use <code>docker cp</code> to copy out of our container and onto our host filesystem. We want the configuration directories, any custom gems we install (required if we want to use modules such as <a href="https://github.com/dayglojesus/managedmac">managedmac</a>), as well as the SSL certificates and some other supporting files (these aren&rsquo;t technically required, but will save having to run <code>puppet agent -t</code> after the container starts every time we update).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>docker cp puppetserver:/etc/puppetserver /usr/local/docker/puppetserver/
</span><span class='line'><span class="nv">$ </span>docker cp puppetserver:/etc/puppet /usr/local/docker/puppetserver/
</span><span class='line'><span class="nv">$ </span>docker cp puppetserver:/var/lib/puppet/ssl /usr/local/docker/puppetserver/lib/
</span><span class='line'><span class="nv">$ </span>docker cp puppetserver:/var/lib/puppet/lib /usr/local/docker/puppetserver/lib/
</span><span class='line'><span class="nv">$ </span>docker cp puppetserver:/var/lib/puppet/jruby-gems /usr/local/docker/puppetserver/
</span></code></pre></td></tr></table></div></figure>


<p>Now we&rsquo;re ready to run for real. Just a small piece of configuration to make our lives easier whilst we&rsquo;re testing &ndash; enabling auto signing of certificates. By default you will need to sign a certificate for each client that tries to connect to your puppet master. Eventually we will want to sign certificates using some sort of external inventory service (I like Sal, but there are also connectors for Web Help Desk), but for now we&rsquo;ll leave our configuration that tells Puppet to sign every certificate unconditionally.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>nano /usr/local/docker/puppetserver/puppet/puppet.conf
</span></code></pre></td></tr></table></div></figure>


<p>And make sure your <code>puppet.conf</code> looks like:</p>

<figure class='code'><figcaption><span>/usr/local/docker/puppetserver/puppet/puppet.conf</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">[</span>main<span class="o">]</span>
</span><span class='line'><span class="nv">logdir</span><span class="o">=</span>/var/log/puppet
</span><span class='line'><span class="nv">vardir</span><span class="o">=</span>/var/lib/puppet
</span><span class='line'><span class="nv">ssldir</span><span class="o">=</span>/var/lib/puppet/ssl
</span><span class='line'><span class="nv">rundir</span><span class="o">=</span>/var/run/puppet
</span><span class='line'><span class="nv">factpath</span><span class="o">=</span><span class="nv">$vardir</span>/lib/facter
</span><span class='line'><span class="nv">pluginsync</span><span class="o">=</span><span class="nb">true</span>
</span><span class='line'><span class="o">[</span>master<span class="o">]</span>
</span><span class='line'><span class="c"># These are needed when the puppetmaster is run by passenger</span>
</span><span class='line'><span class="c"># and can safely be removed if webrick is used.</span>
</span><span class='line'><span class="nv">ssl_client_header</span> <span class="o">=</span> SSL_CLIENT_S_DN
</span><span class='line'><span class="nv">ssl_client_verify_header</span> <span class="o">=</span> SSL_CLIENT_VERIFY
</span><span class='line'><span class="nv">autosign</span> <span class="o">=</span> <span class="nb">true</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now all that remains is to fire up our final container and then we can hook up a client.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># remove our old container</span>
</span><span class='line'><span class="nv">$ </span>docker rm -f puppetserver
</span><span class='line'><span class="nv">$ </span>docker run -d <span class="se">\</span>
</span><span class='line'>  --name<span class="o">=</span><span class="s2">&quot;puppetserver&quot;</span> <span class="se">\</span>
</span><span class='line'>  --restart<span class="o">=</span><span class="s2">&quot;always&quot;</span> <span class="se">\</span>
</span><span class='line'>  -v /usr/local/docker/puppetserver/puppet:/etc/puppet <span class="se">\</span>
</span><span class='line'>  -v /usr/local/docker/puppetserver/puppetserver:/etc/puppetserver <span class="se">\</span>
</span><span class='line'>  -v /usr/local/docker/puppetserver/lib/ssl:/var/lib/puppet/ssl <span class="se">\</span>
</span><span class='line'>  -v /usr/local/docker/puppetserver/jruby-gems:/var/lib/puppet/jruby-gems <span class="se">\</span>
</span><span class='line'>  -v /usr/local/docker/puppetserver/lib/lib:/var/lib/puppet/lib <span class="se">\</span>
</span><span class='line'>  -p 0.0.0.0:8140:8140 <span class="se">\</span>
</span><span class='line'>  -e <span class="nv">PUPPETSERVER_JAVA_ARGS</span><span class="o">=</span><span class="s2">&quot;-Xms384m -Xmx384m -XX:MaxPermSize=256m&quot;</span> <span class="se">\</span>
</span><span class='line'>  -h puppet.yourdomain.com <span class="se">\</span>
</span><span class='line'>  grahamgilbert/puppetserver
</span></code></pre></td></tr></table></div></figure>


<p>Let&rsquo;s make sure it&rsquo;s finished starting up.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>docker logs -f puppetserver
</span></code></pre></td></tr></table></div></figure>


<p>This works like tail would. Hit ctrl-c to exit once it says it&rsquo;s ready to go.</p>

<h1>Hook up a client</h1>

<p>You&rsquo;re going to need Puppet, Facter and Hiera on your client Mac. Head over <a href="http://downloads.puppetlabs.com/mac">http://downloads.puppetlabs.com/mac</a> and download and install the latest version of Puppet, Facter and Hiera.</p>

<p>If we just ran Puppet now, it would use the Mac&rsquo;s hostname as the certificate name (the unique identifier for the machine). If you have reliable hostnames, that will probably do you. I prefer to use the machine&rsquo;s serial number (lower case, because that&rsquo;s what Puppet likes). We&rsquo;ll automate this in a later post, but for now we can do it by hand:</p>

<figure class='code'><figcaption><span>/etc/puppet/puppet.conf</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">[</span>main<span class="o">]</span>
</span><span class='line'><span class="nv">server</span><span class="o">=</span>puppet.yourdomain.com
</span><span class='line'><span class="nv">certname</span><span class="o">=</span>abc123
</span></code></pre></td></tr></table></div></figure>


<p>All that&rsquo;s left now is to run puppet on the client:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>puppet agent -t --waitforcert 20
</span></code></pre></td></tr></table></div></figure>


<p>In a later post, we will look at how we can use r10k to manage our modules and use Hiera to configure our clients without touching a line of Puppet code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using munki-trello with Git]]></title>
    <link href="http://grahamgilbert.com/blog/2015/06/16/using-munki-trello-with-git/"/>
    <updated>2015-06-16T11:21:58+01:00</updated>
    <id>http://grahamgilbert.com/blog/2015/06/16/using-munki-trello-with-git</id>
    <content type="html"><![CDATA[<p>So you&rsquo;re managing your catalogs with <a href="http://grahamgilbert.com/blog/2015/02/11/managing-munki-catalogs-with-trello/">munki-trello</a>, but you also want to use git and <a href="https://www.afp548.com/2014/12/01/git-fat-intro-part-two-setup-and-migration/">git-fat</a> to track the changes &ndash; what do you do?</p>

<p>If you were using the script that I posted previously, your changes would be mangled when you pull in changes  &ndash; it turned out the solution was simple. I&rsquo;m going to assume your Munki server has commit access to your Munki git repository. We&rsquo;re pulling down the latest version of the git repo before performing any work, and then we&rsquo;re git adding just the <code>catalogs</code> and <code>pkgsinfo</code> directories &ndash; the only directories munki-trello will modify. And if there aren&rsquo;t any changes, git won&rsquo;t commit anything, so we can just run <code>git commit</code> and <code>git push</code> without worrying about it.</p>

<p>If we schedule the below script to happen regularly (via cron), we also get our git changes deployed automagically.</p>

<figure class='code'><figcaption><span>/usr/local/bin/munki-trello.sh</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/bin/bash</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Change this to wherever your Munki repository is on disk</span>
</span><span class='line'><span class="nb">cd</span> /usr/local/docker/munki
</span><span class='line'>
</span><span class='line'><span class="c"># Pull down changes</span>
</span><span class='line'>git pull
</span><span class='line'>
</span><span class='line'><span class="c"># and the &#39;fat&#39; files</span>
</span><span class='line'>git fat pull
</span><span class='line'>
</span><span class='line'>docker pull pebbleit/munki-trello
</span><span class='line'>
</span><span class='line'>docker run --rm -v /usr/local/docker/munki:/munki_repo <span class="se">\</span>
</span><span class='line'>-e <span class="nv">DOCKER_TRELLO_KEY</span><span class="o">=</span>mytrellokey <span class="se">\</span>
</span><span class='line'>-e <span class="nv">DOCKER_TRELLO_TOKEN</span><span class="o">=</span>mytrellotoken <span class="se">\</span>
</span><span class='line'>-e <span class="nv">DOCKER_TRELLO_BOARDID</span><span class="o">=</span>myboardid <span class="se">\</span>
</span><span class='line'>pebbleit/munki-trello
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>git add catalogs
</span><span class='line'>git add manifests
</span><span class='line'>git add pkgsinfo
</span><span class='line'>
</span><span class='line'><span class="c"># Change the following line if you want to change the git commit message</span>
</span><span class='line'><span class="nv">now</span><span class="o">=</span><span class="s2">&quot;$(date)&quot;</span>
</span><span class='line'>git commit -m <span class="s2">&quot;Munki Trello commit $now&quot;</span>
</span><span class='line'>
</span><span class='line'>git push
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducing Imagr]]></title>
    <link href="http://grahamgilbert.com/blog/2015/05/08/introducing-imagr/"/>
    <updated>2015-05-08T14:41:37+01:00</updated>
    <id>http://grahamgilbert.com/blog/2015/05/08/introducing-imagr</id>
    <content type="html"><![CDATA[<p>For the past few weeks, I&rsquo;ve been working with some other Mac admins on a new application that can aid with the deployment of Macs &ndash; say hi to <a href="https://github.com/grahamgilbert/imagr">Imagr</a>.</p>

<p><img src="http://grahamgilbert.com/images/posts/2015-05-08/Imagr.png"></p>

<p>It&rsquo;s not intended to be a full replacement for Deploystudio, but it&rsquo;s now got all of the features I need to use Imagr full time. If you&rsquo;d like to get started with Imagr, head on over to the <a href="https://github.com/grahamgilbert/imagr/wiki/Getting-Started">Wiki</a> &ndash; the only requirement is a web server, so the barrier to entry is pretty low (if you followed my guide on how to set up <a href="http://grahamgilbert.com/blog/2015/04/22/getting-started-with-bsdpy-on-docker/">BSDPy</a>, you can use that web server).</p>

<p>I hope you&rsquo;ll give it a go and maybe, just maybe, we can get rid of those little Mac Minis for good!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing BSDPy in Vagrant]]></title>
    <link href="http://grahamgilbert.com/blog/2015/04/28/testing-bsdpy-in-vagrant/"/>
    <updated>2015-04-28T16:10:07+01:00</updated>
    <id>http://grahamgilbert.com/blog/2015/04/28/testing-bsdpy-in-vagrant</id>
    <content type="html"><![CDATA[<p>Last time, we looked at how to spin up a Docker host and run BSDPy on it. That&rsquo;s great for production, but might be a bit of a faff to do every time you want to test your NBI at home.</p>

<p>Inspired by <a href="https://grpugh.wordpress.com/2015/04/28/a-test-docker-bsdpy-environment/">Dr Graham R Pugh</a>, here&rsquo;s my Vagrant setup for this.</p>

<p>You will need:</p>

<ul>
<li><a href="https://www.vagrantup.com/">Vagrant</a></li>
<li>Either <a href="https://www.virtualbox.org/">VirtualBox</a> or <a href="http://www.vmware.com/uk/products/fusion">VMware Fusion</a> (if you use Fusion with Vagrant, you will need to purchase the <a href="http://www.vagrantup.com/vmware">VMware plugin</a> &ndash; this will allow you to create OS X Vagrantboxes as well as enjoy the much greater performance of VMware, but that&rsquo;s another post)</li>
<li>Xcode, or at the very least the command line tools from Xcode so you have git available.</li>
<li>Something to NetBoot &ndash; either a physical Mac or a VM in VMware Fusion. A VM configured as per <a href="https://derflounder.wordpress.com/2013/01/23/building-mac-test-environments-with-vmware-fusion-netboot-and-deploystudio/">Rich Trouton&rsquo;s post</a> will do nicely.</li>
</ul>


<p>Get all of that installed and you&rsquo;re ready to go. Next we need to get the Vagrantfile:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>git clone https://github.com/grahamgilbert/docker-vagrant.git
</span></code></pre></td></tr></table></div></figure>


<p>You will obviously need an NBI &ndash; I&rsquo;ve <a href="http://grahamgilbert.com/blog/2015/04/12/building-custom-netinstalls-with-autonbi/">covered how to use AutoNBI before</a>, or you could use an existing one. Just make sure you&rsquo;ve edited <code>NBImageInfo.plist</code> to make <code>enabled</code> be <code>true</code> and that the Mac (or VM) you&rsquo;re NetBooting isn&rsquo;t in <code>DisabledSystemIdentifiers</code> (I leave this as an empty <code>&lt;array /&gt;</code>). Put your NBI in the <code>nbi</code> directory.</p>

<p>Now there&rsquo;s one thing left to do:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span><span class="nb">cd </span>docker-vagrant
</span><span class='line'><span class="nv">$ </span>vagrant up
</span></code></pre></td></tr></table></div></figure>


<p>Give it 20 seconds to finish booting and you will see your NBI in the startup pane of your Mac.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting started with BSDPy on Docker]]></title>
    <link href="http://grahamgilbert.com/blog/2015/04/22/getting-started-with-bsdpy-on-docker/"/>
    <updated>2015-04-22T07:07:23+01:00</updated>
    <id>http://grahamgilbert.com/blog/2015/04/22/getting-started-with-bsdpy-on-docker</id>
    <content type="html"><![CDATA[<p>Have you heard of Docker, but think it all sounds a bit mystical and exotic? Then this is the post for you! Before we begin, you&rsquo;re going to need a machine (or a VM, either on your machine or on a server) with Ubuntu 14.04 LTS installed on it. You can install Docker on many other operating systems, but I use Ubuntu, so we&rsquo;re using that. Your Ubuntu box will also need a real IP address &ndash; if you are using VMware Fusion, this will be a Bridged Network Adapter &ndash; adjust the terminology if you&rsquo;re using a different virtualization tool. You don&rsquo;t need to worry about giving your machine a static IP unless you want to &ndash; Macs will NetBoot just fine when they&rsquo;re on the same subnet. <!--more--></p>

<h2>Baby Steps</h2>

<p>Our first job is to install Docker. I&rsquo;ve been as guilty as many with glossing over this step, so here&rsquo;s the massively long and difficult method to install the latest version of Docker on Ubuntu 14. First we make sure <code>wget</code> is installed:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>which wget
</span></code></pre></td></tr></table></div></figure>


<p>And if that returns nothing then we need to install <code>wget</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>sudo apt-get update
</span><span class='line'><span class="nv">$ </span>sudo apt-get install wget
</span></code></pre></td></tr></table></div></figure>


<p>And now we can install Docker:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>wget -qO- https://get.docker.com/ | sh
</span></code></pre></td></tr></table></div></figure>


<p>Pop your password in when you&rsquo;re asked and you&rsquo;re done.</p>

<h2>A long time ago on a server far away</h2>

<p>Whilst you&rsquo;re still recovering from the trauma of that difficult install, I&rsquo;m going to cover a bit of background. I&rsquo;ve been using Docker for just under a year now, and I&rsquo;ve developed a method of working with containers that suits me. I&rsquo;m not for one second suggesting this is the best way of working, but it works nicely for me.</p>

<p>On each of my Docker hosts, there is a directory at <code>/usr/local/docker</code> which is where all of my persistent data lives along with a script called <code>startup.sh</code>. All of my Docker related work happens in this script, and it follows this basic pattern:</p>

<ul>
<li>Pull the latest version of the images I&rsquo;m using from the Docker Hub (or my private registry, but that&rsquo;s beyond the scope of this post)</li>
<li>Delete all of the existing containers</li>
<li>Start up the required containers</li>
</ul>


<h2>Why?</h2>

<p>The main reason I do this is that starting up a new container is often no slower than re-starting an existing one, and by using the order of pull &ndash;> delete &ndash;> relaunch, I can be sure that I&rsquo;m always using the latest version of those containers. I&rsquo;m also not having to type out <strong>LOOOOONNNNGGG</strong> <code>docker run</code> commands every time I want to update a container.</p>

<p>The first part of our startup script will be to pull in the images we need. In addition to BSDPy, we need a TFTP server and a basic web server &ndash; fortunately Pepjin has you covered with Images for these already in the <a href="https://registry.hub.docker.com/repos/macadmins/">macadmins organisation</a>.</p>

<p>If you&rsquo;re not made it already, we need to make the directory we&rsquo;ll store our permanent bits:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>sudo -i
</span><span class='line'><span class="nv">$ </span>mkdir -p /usr/local/docker/nbi
</span></code></pre></td></tr></table></div></figure>


<p>And fire up your favourite editor and put in the first part of our script:</p>

<figure class='code'><figcaption><span>/usr/local/docker/startup.sh </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/bin/bash</span>
</span><span class='line'>
</span><span class='line'>docker pull macadmins/tftpd
</span><span class='line'>docker pull macadmins/netboot-httpd
</span><span class='line'>docker pull bruienne/bsdpy:1.0
</span></code></pre></td></tr></table></div></figure>


<p>Now we just need to make it executable and we can run it:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>chmod 755 /usr/local/docker/startup.sh
</span><span class='line'><span class="nv">$ </span>/usr/local/docker/startup.sh
</span></code></pre></td></tr></table></div></figure>


<p>If all goes well Docker will start pulling down the images you need.</p>

<h2>Cleaning up after ourselves</h2>

<p>Pop this little snippet after the last <code>docker pull</code> command &ndash; it will stop and remove any existing containers:</p>

<figure class='code'><figcaption><span>/usr/local/docker/startup.sh</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># Other stuff is above here</span>
</span><span class='line'>docker stop <span class="k">$(</span>docker ps -a -q<span class="k">)</span>
</span><span class='line'>docker rm <span class="k">$(</span>docker ps -a -q<span class="k">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Linked containers</h2>

<p>As previously alluded to, our NetBoot solution will comprise of three components. Add the following to the end of <code>/usr/local/docker/startup.sh</code> (if your server has more than one ethernet adapter, replace <code>eth0</code> with the name of the adapter you want to use for NetBoot):</p>

<figure class='code'><figcaption><span>/usr/local/docker/startup.sh</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># Other stuff is above here</span>
</span><span class='line'>chmod -R 777 /usr/local/docker/nbi
</span><span class='line'><span class="nv">IP</span><span class="o">=</span><span class="sb">`</span>ifconfig eth0 2&gt;/dev/null|awk <span class="s1">&#39;/inet addr:/ {print $2}&#39;</span>|sed <span class="s1">&#39;s/addr://&#39;</span><span class="sb">`</span>
</span><span class='line'><span class="nb">echo</span> <span class="nv">$IP</span>
</span><span class='line'>
</span><span class='line'>docker run -d <span class="se">\</span>
</span><span class='line'>  -v /usr/local/docker/nbi:/nbi <span class="se">\</span>
</span><span class='line'>  --name web <span class="se">\</span>
</span><span class='line'>  --restart<span class="o">=</span>always <span class="se">\</span>
</span><span class='line'>  -p 0.0.0.0:80:80 <span class="se">\</span>
</span><span class='line'>  macadmins/netboot-httpd
</span><span class='line'>
</span><span class='line'>docker run -d <span class="se">\</span>
</span><span class='line'>  -p 0.0.0.0:69:69/udp <span class="se">\</span>
</span><span class='line'>  -v /usr/local/docker/nbi:/nbi <span class="se">\</span>
</span><span class='line'>  --name tftpd <span class="se">\</span>
</span><span class='line'>  --restart<span class="o">=</span>always <span class="se">\</span>
</span><span class='line'>  macadmins/tftpd
</span><span class='line'>
</span><span class='line'>docker run -d <span class="se">\</span>
</span><span class='line'>  -p 0.0.0.0:67:67/udp <span class="se">\</span>
</span><span class='line'>  -v /usr/local/docker/nbi:/nbi <span class="se">\</span>
</span><span class='line'>  -e <span class="nv">BSDPY_IFACE</span><span class="o">=</span>eth0 <span class="se">\</span>
</span><span class='line'>  -e <span class="nv">BSDPY_NBI_URL</span><span class="o">=</span>http://<span class="nv">$IP</span> <span class="se">\</span>
</span><span class='line'>  -e <span class="nv">BSDPY_IP</span><span class="o">=</span><span class="nv">$IP</span> <span class="se">\</span>
</span><span class='line'>  --name bsdpy <span class="se">\</span>
</span><span class='line'>  --restart<span class="o">=</span>always <span class="se">\</span>
</span><span class='line'>  bruienne/bsdpy:1.0
</span></code></pre></td></tr></table></div></figure>


<p>And run your startup script:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>/usr/local/docker/startup.sh
</span></code></pre></td></tr></table></div></figure>


<p>You&rsquo;ll see your images being checked for updates, and then your containers will start. you can verify they&rsquo;re running by running:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>docker ps -a
</span></code></pre></td></tr></table></div></figure>


<h2>Using the thing</h2>

<p>Of course, your NetBoot server isn&rsquo;t going to do anything as you&rsquo;ve not uploaded anything for it to serve yet. Get yourself a NetBoot image (if you&rsquo;re using a DeployStudio NBI, delete the symlink to <code>NetInstall.dmg</code> and rename <code>NetInstall.sparseimage</code> to <code>NetInstall.dmg</code>).</p>

<p>You&rsquo;re not going to have a GUI to modify the <code>NBImageInfo.plist</code> so open it up in a text editor. The important parts to change are to make sure that the Mac you&rsquo;re intending to NetBoot is either in <code>EnabledSystemIdentifiers</code> or not in <code>DisabledSystemIdentifiers</code> and that <code>IsEnabled</code> is set to <code>&lt;true/&gt;</code>. If you are going to be serving more than one image, you can set your default image in here.</p>

<p>All done? Time to get that image on your Docker host. From your admin machine (or wherever your NBI currently lives):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>scp -r /Path/To/MyNetBoot.nbi user@dockerhost:/usr/local/docker/nbi
</span></code></pre></td></tr></table></div></figure>


<p>All that remains is to restart the <code>bsdpy</code> container on your Docker host:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>/usr/local/docker/startup.sh
</span></code></pre></td></tr></table></div></figure>


<p>And if you open up the <code>bsdpy</code> container&rsquo;s logs, you&rsquo;ll see it finding your NBI.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>docker logs bsdpy
</span></code></pre></td></tr></table></div></figure>


<p>And if you want to keep the logs open whilst you&rsquo;re testing, you can use <code>-f</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>docker logs -f bsdpy
</span></code></pre></td></tr></table></div></figure>


<h2>Conclusion</h2>

<p>If you&rsquo;ve made it all the way down here, congratulations! You&rsquo;ve now managed to move another service off that silly little Mac Mini and onto Linux &ndash; and hopefully you now see how easy it is to get things up and running with Docker.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[More fun with AutoNBI]]></title>
    <link href="http://grahamgilbert.com/blog/2015/04/13/more-fun-with-autonbi/"/>
    <updated>2015-04-13T08:05:53+01:00</updated>
    <id>http://grahamgilbert.com/blog/2015/04/13/more-fun-with-autonbi</id>
    <content type="html"><![CDATA[<p>Last time we saw our heroes, there was the unfuffilled promise of making small NetInstall sets. Now is the time to deliver on that promise. We&rsquo;re going to make a small NetInstall that will open up Terminal.app.</p>

<p>If you&rsquo;ve not read the <a href="http://grahamgilbert.com/blog/2015/04/12/building-custom-netinstalls-with-autonbi/">previous post</a> (and have got AutoNBI), go and do it now. I&rsquo;ll wait. All done? <!--more--></p>

<h2>Previously on 24</h2>

<p><img src="http://grahamgilbert.com/images/posts/2015-04-13/jack.gif"></p>

<p>As mentioned in the previous post, we&rsquo;re aiming to have a small NetInstall set. Once you&rsquo;ve made your NetInstall, open up <code>NetInstall.dmg</code> &ndash; you&rsquo;ll see a <code>Packages</code> directory. This is where the majority of the bulk in a NetInstall lives &ndash; the packages it actually installs. There is also a hidden <code>BaseSystem.dmg</code> which is what will load when your NetBoot the machine.</p>

<h2>I&rsquo;m bored, can we make something please?</h2>

<p>As I mentioned above, we&rsquo;re going to make a simple NetInstall that will open up a Terminal window. To do that, we&rsquo;re going to leverage something that Apple kindly left in the image for us &ndash; <code>rc.imaging</code>. A bit of background &ndash; in <code>/etc</code> you&rsquo;ll find a series of <code>rc.*</code> files. One of those in a NetInstall is <code>rc.install</code>, which will look for an <code>rc.imaging</code> file in a few places &ndash; one of those is <code>/System/Installation/Packages/Extras</code> &ndash; conveniently a location that Pepijn has made AutoNBI able to work with.</p>

<p>Somewhere on your Mac, make a directory called <code>Packages</code> and then inside that, make a directory called <code>Extras</code>. Inside that directory we&rsquo;re going to create a file called <code>rc.imaging</code> with the following contents:</p>

<figure class='code'><figcaption><span>Packages/Extras/rc.imaging </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/bin/bash</span>
</span><span class='line'>
</span><span class='line'>/Applications/Utilities/Terminal.app/Contents/MacOS/Terminal
</span><span class='line'>
</span><span class='line'>/sbin/reboot
</span></code></pre></td></tr></table></div></figure>


<p>And make sure it&rsquo;s executable:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>sudo chmod 755 Packages/Extras/rc.imaging
</span><span class='line'><span class="nv">$ </span>sudo chown root:wheel Packages/Extras/rc.imaging
</span></code></pre></td></tr></table></div></figure>


<p>And now to make the NetInstall:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>sudo ./AutoNBI.py -s /Applications/Install<span class="se">\ </span>OS<span class="se">\ </span>X<span class="se">\ </span>Yosemite.app -f Packages -d ~/Desktop -n MyNetInstall -e
</span></code></pre></td></tr></table></div></figure>


<p>The only change from last time is the <code>-f</code> option &ndash; this is the path to your <code>Packages</code> directory. I created my Packages directory in the same directory as AutoNBI.py &ndash; adjust the path if you made yours somewhere else.</p>

<p><img src="http://grahamgilbert.com/images/posts/2015-04-13/netboot.png"></p>

<p>You should now be able to boot off your tiny NBI (mine was 574MB) and have a bit of an explore. You&rsquo;ll notice that quite a bit is missing to achieve this tiny size &ndash; fortunately Pepijn has been working on getting Ruby and Python included in BaseSystem.dmg, so you have more scripting options when booted.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building custom NetInstalls with AutoNBI]]></title>
    <link href="http://grahamgilbert.com/blog/2015/04/12/building-custom-netinstalls-with-autonbi/"/>
    <updated>2015-04-12T20:33:28+01:00</updated>
    <id>http://grahamgilbert.com/blog/2015/04/12/building-custom-netinstalls-with-autonbi</id>
    <content type="html"><![CDATA[<p>Another day, another tool made by <a href="http://enterprisemac.bruienne.com">Mr Bruienne</a>! A while back, Pepijn released <a href="https://bitbucket.org/bruienne/autonbi">AutoNBI</a> &ndash; a tool for automating the creation of NetInstall sets. At the time, it was filled away in the &ldquo;this is cool, but isn&rsquo;t this what System Image Utility does?&rdquo; section. Then I saw his NetInstall running at MacTech (are you seeing a theme here?). It had this really simple DeployStudio like imagaing app &ndash; it was really cool. And suddently it made sense why you can replace the <code>Packages</code> directory with AutoNBI &ndash; a NetInstall is a really stripped down OS X environment, so it it much easier to distribute and use &ndash; we&rsquo;re looking at around 1.8GB for my current NetInstall vs 5-6GB for a normal NetBoot.</p>

<p>This time we&rsquo;ll take a look at how to use AutoNBI to make a standard NetInstall &ndash; in a future post we&rsquo;ll look at some of the more cool things you can do with AutoNBI.</p>

<h2>Ok, stop talking, let&rsquo;s do this.</h2>

<p>We&rsquo;re going to need AutoNBI to start off with. Open up your Terminal and:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>git clone https://bitbucket.org/bruienne/autonbi.git
</span><span class='line'><span class="nv">$ </span><span class="nb">cd </span>autonbi
</span></code></pre></td></tr></table></div></figure>


<h2>Prepare the build!</h2>

<p>We&rsquo;re ready to go (assuming you&rsquo;ve got an OS X installer &ndash; you do, right?). Still in your terminal:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>sudo ./AutoNBI.py -s /Applications/Install<span class="se">\ </span>OS<span class="se">\ </span>X<span class="se">\ </span>Yosemite.app -d ~/Desktop -n MyNetInstall -e
</span></code></pre></td></tr></table></div></figure>


<p>What did we just do? The <code>-s</code> option is simply pointing at our Install OS X Yosemite.app &ndash; if you have it somewhere else, point AutoNBI there. <code>-d</code> is our destination directory and <code>-n</code> is the name of our NetInstall. <code>-e</code> is telling AutoNBI to make the NetInstall enabled.</p>

<p>So the next time there&rsquo;s a new OS X Installer, you can have an updated NetInstall in seconds, not minutes.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Managing Munki catalogs with Trello]]></title>
    <link href="http://grahamgilbert.com/blog/2015/02/11/managing-munki-catalogs-with-trello/"/>
    <updated>2015-02-11T12:11:30+00:00</updated>
    <id>http://grahamgilbert.com/blog/2015/02/11/managing-munki-catalogs-with-trello</id>
    <content type="html"><![CDATA[<p>Over the past few months, I&rsquo;ve been trying to take small pieces of our workflow and see if we can expand on the number of people able to manage it. We&rsquo;ve got <a href="https://github.com/autopkg/autopkg">AutoPkg</a> populating our <a href="https://github.com/munki/munki">Munki</a> repositories without any manual intervention, but we still need to edit pkgsinfo files to move items through development to testing to production catalogs. Sure, there are existing tools  like <a href="https://github.com/munki/munkiwebadmin">MunkiWebAdmin</a> or <a href="https://github.com/hjuutilainen/munkiadmin">MunkiAdmin</a>, but they either still require knowledge of how Munki works or full access to the repository via a file share of some sort. And we obviously already have a tool for assigning software to machines in Sal+ &ndash; we needed something that can speed this incredibly common task.</p>

<p>Then I cast my mind back to a conversation I had with <a href="https://twitter.com/bruienne">Pepijn Bruienne</a> at PSU last year about his workflow using <a href="https://trello.com">Trello</a> to promote items in his Munki repository. So, after pestering him for some information, I devised a workflow that matched how we worked.</p>

<h2>&ldquo;So how does it work&rdquo;, I hear you cry</h2>

<p>We have five lists on our &ldquo;Munki Package Management&rdquo; Trello board. Essentially when the script runs, it inspects the items in our Munki catalog and if they&rsquo;re not already in the Trello board, it adds them to the correct list (we ignore anything that&rsquo;s already in production. All promotions to production are done using this tool now).</p>

<p><img class="center" src="http://grahamgilbert.com/images/posts/2015-02-11/to_testing.gif" width="427" height="240"></p>

<p>We also have lists called &ldquo;To Development&rdquo;, &ldquo;To Testing&rdquo; and &ldquo;To Production&rdquo;. Moving items into these lists will be caught by the script next time it runs, and moved to the appropriate catalog.</p>

<p><img class="center" src="http://grahamgilbert.com/images/posts/2015-02-11/testing.gif" width="427" height="240"></p>

<p>When items finally make it to Production, we add them to a dated Production list. This allows us to have a full history of when things are added to Production and who has moved it through each stage. We&rsquo;re also big users of Slack, so we hooked up it&rsquo;s Tello integration to post a message to our notficiations channel to let our team know when items are added into Munki.</p>

<p>You can grab the script from <a href="https://github.com/pebbleit/munki-trello">pebble.it&rsquo;s GitHub account</a>, or if you&rsquo;re Docker inclined there&rsquo;s a <a href="https://registry.hub.docker.com/u/pebbleit/munki-trello/">container that has everything you need</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Migrating scriptRunner to Outset]]></title>
    <link href="http://grahamgilbert.com/blog/2015/01/04/migrating-scriptrunner-to-outset/"/>
    <updated>2015-01-04T11:40:41+00:00</updated>
    <id>http://grahamgilbert.com/blog/2015/01/04/migrating-scriptrunner-to-outset</id>
    <content type="html"><![CDATA[<p>A while back, Nate Walck wrote <a href="https://github.com/natewalck/Scripts/blob/master/scriptRunner.py">scriptRunner</a>. It&rsquo;s a tool that can run a script either every time a user logs in or just the one time. It has served the test of time, but last year Joe Chilcote released <a href="https://github.com/chilcote/outset">Outset</a>. It has all of the functionality of scriptRunner, but it can also install packages at the Mac&rsquo;s first boot, and run scripts as root at either the first boot or every boot. This comes into it&rsquo;s own when you&rsquo;re trying to do things like skipping the iCloud screens on 10.10 using <a href="https://derflounder.wordpress.com/2014/10/16/disabling-the-icloud-and-diagnostics-pop-up-windows-in-yosemite/">Rich Trouton&rsquo;s script</a> &ndash; this script needs to run after every OS update, so it makes sense to run this every time the Mac boots.</p>

<p>If you&rsquo;ve been using scriptRunner and want to move to Outset, you have two options:</p>

<ul>
<li>Just move your scripts into the appropriate Outset directories and hope your users don&rsquo;t mind the &lsquo;once&rsquo; scripts running a second time.</li>
<li>Or, you could pre-populate Outset&rsquo;s &lsquo;once&rsquo; plist so it won&rsquo;t try to run a script previously run by scriptRunner again.</li>
</ul>


<p>The first option isn&rsquo;t acceptable to me, so I wrote a script that will populate Outset&rsquo;s plist. It&rsquo;s <a href="https://github.com/grahamgilbert/macscripts/tree/master/scriptRunnerToOutset">up on my Github</a>. One caveat is that Outset requires that your scripts end <code>.sh</code>, <code>.rb</code> or <code>.py</code>. scriptRunner didn&rsquo;t care about this. When you&rsquo;re moving your scripts into the Outset directory, you will need to ensure your scripts have the correct extension. This script will read the first line and try to work out what kind of script it is if the file doesn&rsquo;t have the right extension &ndash; if it can&rsquo;t work it out, it will append <code>.sh</code> to the filename.</p>

<p>scriptRunner had a few options you could configure. The first is where your actual scripts live &ndash; you will need to edit line 8 of the script to where you put your scriptRunner scripts. Secondly, you might have changed the name of the plist scriptRunner uses &ndash; edit line 11 if you did this.</p>

<p>Now all that remains is to put this script into <code>/usr/local/outset/login-once</code>. A <a href="https://github.com/unixorn/luggage">Luggage</a> Makefile that will make a package that will do this is included in the repository.</p>

<p>I&rsquo;ve assumed that you can move your scripts into the new Outset directories using your configuration management tool (Munki, Puppet, Capser, whatever), but if you need a tool that can do this for you (with the previously stated caveat about the file extensions of the scripts), you&rsquo;ll find a script that can be dropped into Outset&rsquo;s firstboot directory.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Creating Business Units and Groups in Sal using a CSV]]></title>
    <link href="http://grahamgilbert.com/blog/2014/12/08/creating-business-units-and-groups-in-sal-using-a-csv/"/>
    <updated>2014-12-08T07:52:21+00:00</updated>
    <id>http://grahamgilbert.com/blog/2014/12/08/creating-business-units-and-groups-in-sal-using-a-csv</id>
    <content type="html"><![CDATA[<p>Obviously I&rsquo;m a little biased, but I love Sal. But, it can be a little tedious to get everything set up the first time if you have hundreds of Business Units and Machine Groups. I&rsquo;ve quietly ignored the problem for a while, but then I saw this tweet pop up in my feed:</p>

<blockquote class="twitter-tweet" lang="en"><p><a href="https://twitter.com/hunty1er">@hunty1er</a> Pretty sure you could automate BU/MG creation through the DB backend. What say you <a href="https://twitter.com/grahamgilbert">@grahamgilbert</a> ?</p>&mdash; Pepijn Bruienne (@bruienne) <a href="https://twitter.com/bruienne/status/541811445512830976">December 8, 2014</a></blockquote>


<script async src="http://grahamgilbert.com//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>What say I Mr Bruienne? Like the <a href="https://www.youtube.com/watch?v=mjB9Chw_6FE">man from Del Monte</a>, I say YES!</p>

<h2>The plan</h2>

<p>We&rsquo;re going to use a few of the parts that make Django and Docker awesome. We will:</p>

<ul>
<li>Make a custom management command that will read in a CSV</li>
<li>The command will make the Business Units and Groups if they don&rsquo;t exist</li>
<li>We&rsquo;re than going to run it in a temporary Docker container when we&rsquo;re ready to do the actual import. This is one of the strengths of Docker &ndash; we can spin up a linked container that will operate on the main database, but won&rsquo;t interfere with your container serving the app.</li>
</ul>


<!--more-->


<h2>Let&rsquo;s do this thing</h2>

<p>Custom management commands are where you can add your own command to be available under <code>./manage.py my_command</code> &ndash; and they&rsquo;re pretty easy to make. I&rsquo;ve made a quick and dirty one (that works, but there will probbaly be edge cases where it doesn&rsquo;t).</p>

<p>I&rsquo;m assuming you&rsquo;re running Sal in the recommended way using Docker. If you&rsquo;re not, you can drop the management repo in <code>/path/to/sal/server/management</code>.</p>

<p>To use it, first you&rsquo;re going to need to clone the repository somewhere on your disk. I&rsquo;m going to assume you&rsquo;re working out of <code>/usr/local/docker</code>. There&rsquo;s an example CSV included in the repo.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span><span class="nb">cd</span> /usr/local/docker
</span><span class='line'><span class="nv">$ </span>git clone https://github.com/grahamgilbert/sal-import-example
</span></code></pre></td></tr></table></div></figure>


<p>Next we&rsquo;re going to run a temporary Docker container on the same host that our existing Sal container is running on. This container will run the import, and when it&rsquo;s done it will delete itself (<code>--rm</code>). We&rsquo;ve linked in the import data and the additional management command. So we can see the output, we&rsquo;re running it in the foreground as well (<code>-i</code>). Finally, we run the custom management command and point it to the CSV.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>docker run -t -i -v /vagrant/sal/settings.py:/home/docker/sal/sal/settings.py <span class="se">\</span>
</span><span class='line'>  -e <span class="nv">ADMIN_PASS</span><span class="o">=</span>pass <span class="se">\</span>
</span><span class='line'>  -e <span class="nv">DB_NAME</span><span class="o">=</span>sal <span class="se">\</span>
</span><span class='line'>  -e <span class="nv">DB_USER</span><span class="o">=</span>admin <span class="se">\</span>
</span><span class='line'>  -e <span class="nv">DB_PASS</span><span class="o">=</span>password <span class="se">\</span>
</span><span class='line'>  --link postgres-sal:db <span class="se">\</span>
</span><span class='line'>  --rm <span class="se">\</span>
</span><span class='line'>  -v /vagrant/sal/management:/home/docker/sal/server/management <span class="se">\</span>
</span><span class='line'>  -v /vagrant/sal/data.csv:/data.csv <span class="se">\</span>
</span><span class='line'>  macadmins/sal <span class="se">\</span>
</span><span class='line'>  python /home/docker/sal/manage.py loadcsv /data.csv
</span></code></pre></td></tr></table></div></figure>


<p>And you&rsquo;ll get the output reporting that your CSV did it&rsquo;s job:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Omni Mega Corp didn<span class="s1">&#39;t exist and has been created.</span>
</span><span class='line'><span class="s1">Machine Group 1 didn&#39;</span>t exist and has been created.
</span><span class='line'>Omni Mega Corp already exists.
</span><span class='line'>Machine Group 2 didn<span class="s1">&#39;t exist and has been created.</span>
</span><span class='line'><span class="s1">Honest Bob&#39;</span>s Burgers didn<span class="s1">&#39;t exist and has been created.</span>
</span><span class='line'><span class="s1">Machine Group 3 didn&#39;</span>t exist and has been created.
</span></code></pre></td></tr></table></div></figure>


<p>There it is &ndash; a simple management command to automate tasks with Sal and running it in a temporary Docker container. You can use the temporary container technique for many tasks &ndash; performing a <code>repo_sync</code> on a <a href="https://registry.hub.docker.com/u/macadmins/reposado/">Reposado container</a> is a good example.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Slides and notes from Twisting Munki]]></title>
    <link href="http://grahamgilbert.com/blog/2014/11/07/slides-and-notes-from-twisting-munki/"/>
    <updated>2014-11-07T00:51:33+00:00</updated>
    <id>http://grahamgilbert.com/blog/2014/11/07/slides-and-notes-from-twisting-munki</id>
    <content type="html"><![CDATA[<p>Firstly, thanks if you came to my talk and putting up with me! You can get my slides and code from the <a href="https://github.com/grahamgilbert/mactech_2014">GitHub repository</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[first-boot-pkg updated for Yosemite]]></title>
    <link href="http://grahamgilbert.com/blog/2014/10/21/first-boot-pkg-updated-for-yosemite/"/>
    <updated>2014-10-21T11:50:28+01:00</updated>
    <id>http://grahamgilbert.com/blog/2014/10/21/first-boot-pkg-updated-for-yosemite</id>
    <content type="html"><![CDATA[<p>It seems like Yosemite introduced an <a href="https://github.com/munki/createOSXinstallPkg#further-note-on-additional-packages-and-yosemite">undocumented change</a> that requires any packages that are added an OS X installer (e.g. Netinstall or createOSXinstallPkg) be distribution style packages, or you get a nasty failure acompanied by one of the most unhelpful error messages ever.</p>

<p>To fix this, <a href="https://github.com/grahamgilbert/first-boot-pkg">first-boot-pkg</a> now builds distribution style packages.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[London Apple Admins]]></title>
    <link href="http://grahamgilbert.com/blog/2014/08/24/london-apple-admins/"/>
    <updated>2014-08-24T17:17:24+01:00</updated>
    <id>http://grahamgilbert.com/blog/2014/08/24/london-apple-admins</id>
    <content type="html"><![CDATA[<p>I&rsquo;m delighted to say that the first (first meet that isn&rsquo;t &ldquo;let&rsquo;s go to the pub and get drunk&rdquo;, anyway!) <a href="http://www.londonappleadmins.org.uk">London Apple Admins</a> meetup is happening on the 3rd September at <a href="http://theredherring.co.uk/">The Red Herring in St Pauls</a>. I&rsquo;d like to take all of the credit for organising it, but it was down to the hard work of <a href="http://macmule.com">Ben Toms</a>. The theme this time is &ldquo;this is what I&rsquo;m working on at the moment&rdquo;, so I&rsquo;ll be talking about my new favourite toy, <a href="https://www.docker.com">Docker</a>.</p>

<p>If you&rsquo;ll be in or around London on the 3rd September, <a href="https://www.eventbrite.com/e/london-apple-admins-sept-2014-tickets-12545591201">please get yourself a ticket</a> (they&rsquo;re free) and come and have a beer or two whilst listening to some awesome talks by London based Mac Admins.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Personal Automation: Munki (Part 2)]]></title>
    <link href="http://grahamgilbert.com/blog/2014/07/27/personal-automation-munki-part-2/"/>
    <updated>2014-07-27T11:21:37+01:00</updated>
    <id>http://grahamgilbert.com/blog/2014/07/27/personal-automation-munki-part-2</id>
    <content type="html"><![CDATA[<p>The first step to getting any Mac set up is to get some software onto it. I&rsquo;m not going to cover how to set up <a href="https://code.google.com/p/munki/wiki/GettingStartedWithMunki">Munki</a> or <a href="https://github.com/autopkg/autopkg/wiki/Getting-Started">AutoPkg</a> &ndash; there are lots of other places for that information.</p>

<p>As a sysadmin, I&rsquo;m forever testing things. Rather than destroy my own machine, I like to do this in Virtual Machines. My preferred virtualisation solution is VMware Fusion, but unfortunately it&rsquo;s not very easy to deploy out of the box. You need to do a little bit of work to get it into a package that you can import into Munki, but fortunately the process is <a href="http://kb.vmware.com/selfservice/microsites/search.do?language=en_US&amp;cmd=displayKC&amp;externalId=2058680">well documented on VMware&rsquo;s site</a>.</p>

<p>The next piece of &lsquo;non standard&rsquo; software I need is <a href="http://brew.sh">Homebrew</a>. The installation method listed on their site is to run a terminal command as the current user. The first part of this is obviously fine &ndash; Munki has several methods to run scripts (payload free packages, nopkg), but it runs everything as root. Fortunately, as I&rsquo;m deploying my own machine, I can make some assumptions about where Homebrew will be installed. The first assumption I can make is that there will only be one user on the machine, and the second is that I&rsquo;m going to be logged in most of the time (as my laptop is encrypted, it&rsquo;s either off or logged in).</p>

<p>I&rsquo;m going to utilise a <code>nopkg</code> pkginfo file to perform the installation. The first part of our script to install Homebrew is to make sure that a user (me!) is logged in. Homebrew doesn&rsquo;t like being owned by root, so first we need to make sure that there is a user logged in.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/bin/bash</span>
</span><span class='line'>
</span><span class='line'><span class="nv">CURRENT_USER</span><span class="o">=</span><span class="sb">`</span>/bin/ls -l /dev/console | /usr/bin/awk <span class="s1">&#39;{ print $3 }&#39;</span><span class="sb">`</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;$CURRENT_USER&quot;</span> <span class="o">==</span> <span class="s1">&#39;root&#39;</span> <span class="o">]</span>; <span class="k">then</span>
</span><span class='line'>    <span class="c"># this can&#39;t run at the login window, we need the current user</span>
</span><span class='line'>    <span class="nb">exit </span>1
</span><span class='line'><span class="k">fi</span>
</span></code></pre></td></tr></table></div></figure>


<p>So now we know that there&rsquo;s a user logged in, and who that user is. Time to install Homebrew as the current user.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>mkdir -p /usr/local
</span><span class='line'>mkdir -p /usr/local/homebrew
</span><span class='line'>mkdir -p /usr/local/bin
</span><span class='line'>chown <span class="nv">$CURRENT_USER</span>:_developer /usr/local/homebrew
</span><span class='line'>chown <span class="nv">$CURRENT_USER</span>:_developer /usr/local/bin
</span><span class='line'>
</span><span class='line'><span class="c">#download and install homebrew</span>
</span><span class='line'>su <span class="nv">$CURRENT_USER</span> -c <span class="s2">&quot;/bin/bash -o pipefail -c &#39;/usr/bin/curl -skSfL https://github.com/mxcl/homebrew/tarball/master | (cd /usr/local ; /usr/bin/tar xz -m --strip 1 -C homebrew; ln -s /usr/local/homebrew/bin/brew /usr/local/bin/brew)&#39;&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>As we&rsquo;re using a <code>nopkg</code> with Munki rather than a payload free package, we&rsquo;ve not left any receipts, so Munki doesn&rsquo;t know if Homebrew is installed. We&rsquo;re going to use an installs array to tell Munki what to look for when determining whether Homebrew is installed or not.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;key&gt;</span>installs<span class="nt">&lt;/key&gt;</span>
</span><span class='line'>  <span class="nt">&lt;array&gt;</span>
</span><span class='line'>      <span class="nt">&lt;dict&gt;</span>
</span><span class='line'>          <span class="nt">&lt;key&gt;</span>path<span class="nt">&lt;/key&gt;</span>
</span><span class='line'>          <span class="nt">&lt;string&gt;</span>/usr/local/bin/brew<span class="nt">&lt;/string&gt;</span>
</span><span class='line'>          <span class="nt">&lt;key&gt;</span>type<span class="nt">&lt;/key&gt;</span>
</span><span class='line'>          <span class="nt">&lt;string&gt;</span>file<span class="nt">&lt;/string&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/dict&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/array&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>You might be crying &ldquo;but Homebrew needs the Xcode Command Line Tools installed!&rdquo; &ndash; and you&rsquo;d be 100% correct. You have the option of importing the downloaded package into Munki, but I have adapted <a href="https://github.com/timsutton/osx-vm-templates/blob/master/scripts/xcode-cli-tools.sh">Tim Sutton&rsquo;s script</a> into a <code>nopkg</code>. To find out what&rsquo;s installed, I ran <a href="http://www.fernlightning.com/doku.php?id=software%3afseventer%3astart">fseventer</a> and chose a random file to act as my installs array. I&rsquo;ve posted the pkginfos for both the <a href="https://github.com/grahamgilbert/macscripts/blob/master/Munki/pkginfos/Xcode/XcodeCLITools-2014.07.15.plist">Xcode CLI tools</a> and all of the <a href="https://github.com/grahamgilbert/macscripts/tree/master/Munki/pkginfos/Homebrew">Homebrew installs</a> on Github.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Personal Automation (Part 1)]]></title>
    <link href="http://grahamgilbert.com/blog/2014/07/26/personal-automation-part-1/"/>
    <updated>2014-07-26T11:27:00+01:00</updated>
    <id>http://grahamgilbert.com/blog/2014/07/26/personal-automation-part-1</id>
    <content type="html"><![CDATA[<p><a href="http://grahamgilbert.com/blog/2014/04/04/updating-boxen/">Earlier this year</a>, I professed my love of Boxen &ndash; the personal automation solution based on Puppet released by Github. Indeed, it served me well for quite some time, but I began to find myself spending more time fixing Boxen than actually getting things done. As Boxen was designed for internal use at Github, it set some things up how they liked them &ndash; which wasn&rsquo;t necesarily how I liked them. Sysadmins have similar needs to developers, but not exactly the same.</p>

<p>Then I updated Boxen. All of my modules were out of date, so I spent a good couple of hours updating all of them so they worked again. Ugh.</p>

<p>So I started looking at moving to my own solution. One of my major irritations when using Boxen was that it didn&rsquo;t really handle updating your apps &ndash; you got whatever version the module author decided to install and then you had to hope that there was an updatng mechanism built in. I&rsquo;ve said before that there is no better method of getting software onto your Mac then Munki, so the first decison was straightforward. The rest took a little thought.</p>

<h2>The six P&rsquo;s</h2>

<p>My first requirement was that I shouldn&rsquo;t need to run anything to get my configuration to apply. Boxen requires that you run the <code>boxen</code> command periodically across each of your Macs to get the configuration applied. This wasn&rsquo;t always practical. I needed something that would run in the background and keep itself up to date.</p>

<p>As I said before, I really disliked how Boxen installs software. Munki does a much better job, and AutoPkg makes it trivial to make sure you have the latest software version. Being a sysadmin, I need more than simple drag and drop apps and packages though &ndash; I make extensive use of <a href="http://brew.sh">Homebrew</a> to install command line tools like <a href="http://packer.io">Packer</a>, so I needed to come up with a way of installing these with Munki.</p>

<p>However, Munki isn&rsquo;t the best tool for managing my configuration. I&rsquo;ve been using Puppet to manage the Macs  I look after for nearly three years now, and I wanted to base my system on it as I&rsquo;ve already done a lot of the work with making OS X specific modules. I also wanted to use the modules made for Boxen as much as possible (some made too many assumptions about where they were running, so couldn&rsquo;t be re-used.</p>

<p>So to recap:</p>

<ul>
<li>Munki for software deployment.</li>
<li>Puppet must run in the background periodically</li>
<li>The configuration must update itself &ndash; I don&rsquo;t want to have to sync code across machines.</li>
<li>Where possible, re-use existing Puppet modules</li>
</ul>


<p>Over the next few posts, I&rsquo;ll go over the different parts of this solution, how I put it together and how you might be able to use this.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automate yourself out of a job]]></title>
    <link href="http://grahamgilbert.com/blog/2014/07/10/automate-yourself-out-of-a-job/"/>
    <updated>2014-07-10T20:39:33+01:00</updated>
    <id>http://grahamgilbert.com/blog/2014/07/10/automate-yourself-out-of-a-job</id>
    <content type="html"><![CDATA[<p>A massive thanks to everyone who came to my talk today, and thanks to everyone who helped out with the Q&amp;A at the end. All of the code I used in the talk is <a href="https://github.com/grahamgilbert/automate_psu_2014">up on GitHub</a> and <a href="http://grahamgilbert.com/images/posts/2014-07-10/Automate_yourself_out_of_a_job.pdf">here are the slides</a>. Hopefully the video will convey how much fun it actually was &ndash; it could have been a disaster, so I&rsquo;m hugely grateful to everyone who contributed to the discussion at the end.</p>
]]></content>
  </entry>
  
</feed>
